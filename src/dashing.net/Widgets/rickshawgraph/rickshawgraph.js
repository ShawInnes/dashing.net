// Generated by CoffeeScript 1.7.1
(function() {
  var hslToRgb, interpolate, isString, parseColor, parseRgbaColor, rgbToColor, rgbToHsl,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Dashing.Rickshawgraph = (function(_super) {
    var DIVISORS, computeDefaultColors, formatNumber, graphiteDataToRickshaw;

    __extends(Rickshawgraph, _super);

    function Rickshawgraph() {
      return Rickshawgraph.__super__.constructor.apply(this, arguments);
    }

    DIVISORS = [
      {
        number: 100000000000000000000000,
        label: 'Y'
      }, {
        number: 100000000000000000000,
        label: 'Z'
      }, {
        number: 100000000000000000,
        label: 'E'
      }, {
        number: 1000000000000000,
        label: 'P'
      }, {
        number: 1000000000000,
        label: 'T'
      }, {
        number: 1000000000,
        label: 'G'
      }, {
        number: 1000000,
        label: 'M'
      }, {
        number: 1000,
        label: 'K'
      }
    ];

    formatNumber = function(number) {
      var divisior, _i, _len;
      for (_i = 0, _len = DIVISORS.length; _i < _len; _i++) {
        divisior = DIVISORS[_i];
        if (number > divisior.number) {
          number = "" + (Math.round(number / (divisior.number / 10)) / 10) + divisior.label;
          break;
        }
      }
      return number;
    };

    Rickshawgraph.prototype.getRenderer = function() {
      return this.get('renderer') || this.get('graphtype') || 'area';
    };

    Rickshawgraph.accessor('current', function() {
      var answer, data, index, point, s, series, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;
      answer = null;
      if (this.get('displayedValue') !== null && this.get('displayedValue') !== void 0) {
        answer = this.get('displayedValue');
      }
      if (answer === null) {
        series = this._parseData({
          points: this.get('points'),
          series: this.get('series')
        });
        if (!((series != null ? series.length : void 0) > 0)) {
          answer = '';
        } else {
          switch (this.get('summaryMethod')) {
            case "sum":
              answer = 0;
              for (_i = 0, _len = series.length; _i < _len; _i++) {
                s = series[_i];
                _ref = s.data;
                for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                  point = _ref[_j];
                  answer += (point != null ? point.y : void 0) || 0;
                }
              }
              break;
            case "sumLast":
              answer = 0;
              for (_k = 0, _len2 = series.length; _k < _len2; _k++) {
                s = series[_k];
                answer += s.data[s.data.length - 1].y || 0;
              }
              break;
            case "highest":
              answer = 0;
              if (this.get('unstack') || (this.getRenderer() === "line")) {
                for (_l = 0, _len3 = series.length; _l < _len3; _l++) {
                  s = series[_l];
                  _ref1 = s.data;
                  for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
                    point = _ref1[_m];
                    answer = Math.max(answer, (point != null ? point.y : void 0) || 0);
                  }
                }
              } else {
                for (index = _n = 0, _ref2 = series[0].data.length; 0 <= _ref2 ? _n < _ref2 : _n > _ref2; index = 0 <= _ref2 ? ++_n : --_n) {
                  value = 0;
                  for (_o = 0, _len5 = series.length; _o < _len5; _o++) {
                    s = series[_o];
                    value += ((_ref3 = s.data[index]) != null ? _ref3.y : void 0) || 0;
                  }
                  answer = Math.max(answer, value);
                }
              }
              break;
            case "none":
              answer = '';
              break;
            default:
              if (series.length === 1 && ((_ref4 = series[0].data) != null ? _ref4.length : void 0) > 0) {
                data = series[0].data;
                answer = data[data.length - 1].y;
              } else {
                answer = '';
              }
          }
          answer = formatNumber(answer);
        }
      }
      return answer;
    });

    Rickshawgraph.prototype.ready = function() {
      if (this.get('colors')) {
        this.assignedColors = this.get('colors').split(':');
      }
      if (this.get('strokeColors')) {
        this.strokeColors = this.get('strokeColors').split(':');
      }
      this.graph = this._createGraph();
      return this.graph.render();
    };

    Rickshawgraph.prototype.clear = function() {
      var $node;
      $node = $(this.node);
      $node.find('.rickshaw_graph').remove();
      if (this.$legendDiv) {
        this.$legendDiv.remove();
        return this.$legendDiv = null;
      }
    };

    Rickshawgraph.prototype.onData = function(data) {
      var index, needClear, series, subseries, _i, _j, _len, _len1, _ref, _ref1;
      series = this._parseData(data);
      if (this.graph) {
        needClear = false;
        needClear |= series.length !== this.graph.series.length;
        if (this.get("legend")) {
          for (index = _i = 0, _len = series.length; _i < _len; index = ++_i) {
            subseries = series[index];
            needClear |= ((_ref = this.graph.series[index]) != null ? _ref.name : void 0) !== ((_ref1 = series[index]) != null ? _ref1.name : void 0);
          }
        }
        if (needClear) {
          this.graph = this._createGraph();
        }
        for (index = _j = 0, _len1 = series.length; _j < _len1; index = ++_j) {
          subseries = series[index];
          this.graph.series[index] = subseries;
        }
        return this.graph.render();
      }
    };

    Rickshawgraph.prototype._createGraph = function() {
      var $container, $graph, $node, err, graph, graphOptions, height, legend, nullsFound, point, s, series, width, xAxisOptions, x_axis, y_axis, _i, _j, _len, _len1, _ref;
      $node = $(this.node);
      $container = $node.parent();
      this.clear();
      width = (Dashing.widget_base_dimensions[0] * $container.data("sizex")) + Dashing.widget_margins[0] * 2 * ($container.data("sizex") - 1);
      height = Dashing.widget_base_dimensions[1] * $container.data("sizey");
      if (this.get("legend")) {
        height -= 20;
      }
      $graph = $("<div style='height: " + height + "px;'></div>");
      $node.append($graph);
      series = this._parseData({
        points: this.get('points'),
        series: this.get('series')
      });
      graphOptions = {
        element: $graph.get(0),
        renderer: this.getRenderer(),
        width: width,
        height: height,
        series: series
      };
      if (!!this.get('stroke')) {
        graphOptions.stroke = true;
      }
      if (this.get('min') !== null) {
        graphOptions.max = this.get('min');
      }
      if (this.get('max') !== null) {
        graphOptions.max = this.get('max');
      }
      try {
        graph = new Rickshaw.Graph(graphOptions);
      } catch (_error) {
        err = _error;
        if (err.toString() === "x and y properties of points should be numbers instead of number and object") {
          nullsFound = false;
          for (_i = 0, _len = series.length; _i < _len; _i++) {
            s = series[_i];
            _ref = s.data;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              point = _ref[_j];
              if (point.y === null) {
                nullsFound = true;
                point.y = 0;
              }
            }
          }
          if (nullsFound) {
            graph = new Rickshaw.Graph(graphOptions);
            if (!this.rickshawVersionWarning) {
              console.log(("" + (this.get('id')) + " - Nulls were found in your data, but Rickshaw didn't like") + " them.  Consider upgrading your rickshaw to 1.4.3 or higher.");
              this.rickshawVersionWarning = true;
            }
          } else {
            throw err;
          }
        }
      }
      graph.renderer.unstack = !!this.get('unstack');
      xAxisOptions = {
        graph: graph
      };
      if (Rickshaw.Fixtures.Time.Local) {
        xAxisOptions.timeFixture = new Rickshaw.Fixtures.Time.Local();
      }
      x_axis = new Rickshaw.Graph.Axis.Time(xAxisOptions);
      y_axis = new Rickshaw.Graph.Axis.Y({
        graph: graph,
        tickFormat: Rickshaw.Fixtures.Number.formatKMBT
      });
      if (this.get("legend")) {
        this.$legendDiv = $("<div style='width: " + width + "px;'></div>");
        $node.append(this.$legendDiv);
        legend = new Rickshaw.Graph.Legend({
          graph: graph,
          element: this.$legendDiv.get(0)
        });
      }
      return graph;
    };

    Rickshawgraph.prototype._parseData = function(data) {
      var dataSeries, err, index, points, series, subseries, _i, _len;
      series = [];
      if (data.series) {
        dataSeries = isString(data.series) ? JSON.parse(data.series) : data.series;
        for (index = _i = 0, _len = dataSeries.length; _i < _len; index = ++_i) {
          subseries = dataSeries[index];
          try {
            series.push(this._parseSeries(subseries));
          } catch (_error) {
            err = _error;
            console.log("Error while parsing series: " + err);
          }
        }
      } else if (data.points) {
        points = data.points;
        if (isString(points)) {
          points = JSON.parse(points);
        }
        if ((points[0] != null) && (points[0].x == null)) {
          points = graphiteDataToRickshaw(points);
        }
        series.push({
          data: points
        });
      }
      if (series.length === 0) {
        series.push({
          data: [
            {
              x: 0,
              y: 0
            }
          ]
        });
      }
      this._updateColors(series);
      if (Rickshaw.Series.fill) {
        Rickshaw.Series.fill(series, null);
      }
      return series;
    };

    Rickshawgraph.prototype._parseSeries = function(series) {
      var answer;
      if ((series != null ? series.datapoints : void 0) != null) {
        answer = {
          name: series.target,
          data: graphiteDataToRickshaw(series.datapoints),
          color: series.color,
          stroke: series.stroke
        };
      } else if ((series != null ? series.data : void 0) != null) {
        answer = {
          name: series.name,
          data: series.data,
          color: series.color,
          stroke: series.stroke
        };
      } else if (!series) {
        throw new Error("No data received for " + (this.get('id')));
      } else {
        throw new Error("Unknown data for " + (this.get('id')) + ".  series: " + series);
      }
      answer.data.sort(function(a, b) {
        return a.x - b.x;
      });
      return answer;
    };

    Rickshawgraph.prototype._updateColors = function(series) {
      var index, subseries, _i, _len, _ref, _ref1, _ref2, _results;
      if (!this.defaultColors || ((_ref = this.defaultColors) != null ? _ref.length : void 0) !== series.length) {
        this.defaultColors = computeDefaultColors(this, this.node, series);
      }
      _results = [];
      for (index = _i = 0, _len = series.length; _i < _len; index = ++_i) {
        subseries = series[index];
        if (subseries.color == null) {
          subseries.color = ((_ref1 = this.assignedColors) != null ? _ref1[index] : void 0) || this.defaultColors[index];
        }
        _results.push(subseries.stroke != null ? subseries.stroke : subseries.stroke = ((_ref2 = this.strokeColors) != null ? _ref2[index] : void 0) || "#000");
      }
      return _results;
    };

    graphiteDataToRickshaw = function(datapoints) {
      var answer, datapoint, _i, _len;
      answer = [];
      for (_i = 0, _len = datapoints.length; _i < _len; _i++) {
        datapoint = datapoints[_i];
        answer.push({
          x: datapoint[1],
          y: datapoint[0] || 0
        });
      }
      return answer;
    };

    computeDefaultColors = function(self, node, series) {
      var alpha, backgroundColor, defaultColors, hsl, hue, hueOffset, hues, index, luminance, luminanceSource, luminances, saturation, saturationSource, saturations, _i, _j, _k, _len, _ref, _ref1, _ref2;
      defaultColors = [];
      backgroundColor = parseColor($(node).css('background-color')) || [50, 50, 50, 1.0];
      hsl = rgbToHsl(backgroundColor);
      alpha = self.get('defaultAlpha') != null ? self.get('defaultAlpha') : 1;
      if ((_ref = self.get('colorScheme')) === 'rainbow' || _ref === 'near-rainbow') {
        saturation = (interpolate(hsl[1], 1.0, 3))[1];
        luminance = hsl[2] < 0.6 ? 0.7 : 0.3;
        hueOffset = 0;
        if (self.get('colorScheme') === 'rainbow') {
          hues = interpolate(hsl[0], hsl[0] + 1, series.length + 2);
          hueOffset = 1;
        } else {
          hues = interpolate(hsl[0] - 0.25, hsl[0] + 0.25, series.length);
        }
        for (index = _i = 0, _len = hues.length; _i < _len; index = ++_i) {
          hue = hues[index];
          if (hue > 1) {
            hues[index] -= 1;
          }
          if (hue < 0) {
            hues[index] += 1;
          }
        }
        for (index = _j = 0, _ref1 = series.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; index = 0 <= _ref1 ? ++_j : --_j) {
          defaultColors[index] = rgbToColor(hslToRgb([hues[index + hueOffset], saturation, luminance, alpha]));
        }
      } else {
        hue = self.get('colorScheme') === "compliment" ? hsl[0] + 0.5 : hsl[0];
        if (hsl[0] > 1) {
          hsl[0] -= 1;
        }
        saturation = hsl[1];
        saturationSource = saturation < 0.6 ? 0.7 : 0.3;
        saturations = interpolate(saturationSource, saturation, series.length + 1);
        luminance = hsl[2];
        luminanceSource = luminance < 0.6 ? 0.9 : 0.1;
        luminances = interpolate(luminanceSource, luminance, series.length + 1);
        for (index = _k = 0, _ref2 = series.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; index = 0 <= _ref2 ? ++_k : --_k) {
          defaultColors[index] = rgbToColor(hslToRgb([hue, saturations[index], luminances[index], alpha]));
        }
      }
      return defaultColors;
    };

    return Rickshawgraph;

  })(Dashing.Widget);

  isString = function(obj) {
    return toString.call(obj) === "[object String]";
  };

  parseRgbaColor = function(colorString) {
    var match;
    match = /^rgb\(\s*([\d]+)\s*,\s*([\d]+)\s*,\s*([\d]+)\s*\)/.exec(colorString);
    if (match) {
      return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3]), 1.0];
    }
    match = /^rgba\(\s*([\d]+)\s*,\s*([\d]+)\s*,\s*([\d]+)\s*,\s*([\d]+)\s*\)/.exec(colorString);
    if (match) {
      return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3]), parseInt(match[4])];
    }
    return null;
  };

  parseColor = function(colorString) {
    var answer, div, match;
    answer = null;
    div = document.createElement('div');
    div.style.color = colorString;
    if (div.style.color) {
      answer = parseRgbaColor(div.style.color);
    }
    if (!answer) {
      match = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/.exec(colorString);
      if (match) {
        answer = [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16), 1.0];
      }
    }
    if (!answer) {
      match = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])/.exec(colorString);
      if (match) {
        answer = [parseInt(match[1], 16) * 0x11, parseInt(match[2], 16) * 0x11, parseInt(match[3], 16) * 0x11, 1.0];
      }
    }
    if (!answer) {
      answer = parseRgbaColor(colorString);
    }
    return answer;
  };

  rgbToColor = function(rgb) {
    if ((!3 in rgb) || (rgb[3] === 1.0)) {
      return "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
    } else {
      return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + rgb[3] + ")";
    }
  };

  interpolate = function(source, dest, steps) {
    var answer, num, stepSize;
    if (steps < 2) {
      answer = [dest];
    } else {
      stepSize = (dest - source) / (steps - 1);
      answer = (function() {
        var _i, _results;
        _results = [];
        for (num = _i = source; stepSize > 0 ? _i <= dest : _i >= dest; num = _i += stepSize) {
          _results.push(num);
        }
        return _results;
      })();
      if (answer.length < steps) {
        answer.push(dest);
      }
    }
    return answer;
  };

  rgbToHsl = function(rgba) {
    var a, b, d, g, h, l, max, min, r, s, _ref;
    r = rgba[0], g = rgba[1], b = rgba[2], a = rgba[3];
    r /= 255;
    g /= 255;
    b /= 255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + ((_ref = g < b) != null ? _ref : {
            6: 0
          });
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return [h, s, l, a];
  };

  hslToRgb = function(hsla) {
    var a, b, g, h, hue2rgb, l, p, q, r, s;
    h = hsla[0], s = hsla[1], l = hsla[2], a = hsla[3];
    if (s === 0) {
      r = g = b = l;
    } else {
      hue2rgb = function(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      };
      q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a];
  };

}).call(this);

//# sourceMappingURL=rickshawgraph.map
